# -*- coding: utf-8 -*-
"""V40Stochastic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O8rz6VOjOax6OKsRBBFqxJZcEKnvvVkV
"""

# import pandas as pd
# import matplotlib.pyplot as plt
# import yfinance as yf

# # Download historical data for TCS
# data = yf.download('TCS.BO', start='2023-08-31', end='2024-08-31')

# # Calculate %K
# data['Lowest Low'] = data['Low'].rolling(window=4).min()
# data['Highest High'] = data['High'].rolling(window=4).max()
# # if (data['Highest High'] == data['Lowest Low']).any():
# #   print("Equal rows found:")
# #   print(data[data['Highest High'] == data['Lowest Low']])

# # valid_range = (data['Highest High'] != data['Lowest Low'])
# # data.loc[valid_range, '%KD'] = ((data['Close'] - data['Lowest Low']) / (data['Highest High'] - data['Lowest Low'])) * 100


# data['%K'] = None  # Initialize the column

# for i in range(len(data)):
#     lowest_low = data['Lowest Low'].iloc[i]
#     highest_high = data['Highest High'].iloc[i]
#     close = data['Close'].iloc[i]
#     print("Lowest Low")
#     print(lowest_low)
#     print("highest_high")
#     print(highest_high)
#     print("close")
#     print(close)
#     # Ensure no division by zero
#     if highest_high != lowest_low:
#         data.at[i, '%K'] = ((close - lowest_low) / (highest_high - lowest_low)) * 100
#     else:
#         data.at[i, '%K'] = None  # Or 0, depending on the desired behavior


# # data['%K'] = ((data['Close'] - data['Lowest Low']) / (data['Highest High'] - data['Lowest Low'])) * 100

# # Calculate %D
# data['%D'] = data['%K'].rolling(window=3).mean()

# # Plotting
# plt.figure(figsize=(14, 7))
# plt.plot(data.index, data['%K'], label='%K', color='blue')
# plt.plot(data.index, data['%D'], label='%D', color='red')
# plt.title('Stochastic Oscillator for TCS')
# plt.xlabel('Date')
# plt.ylabel('Value')
# plt.legend()
# plt.grid(True)
# plt.show()

# # Print %K and %D values for the last 10 days
# latest_data = data.tail(10)[['%K', '%D']]
# print("Date\t\t\t%K\t%D")
# for index, row in latest_data.iterrows():
#     print(f"{index.date()}\t{row['%K']:.2f}\t{row['%D']:.2f}")

# Data with V40 and V40Next
data_v40 = [
    "NIFTYBEES",
    "RELIANCE",
    "BANKBEES",
    "HDFCBANK",
    "ICICIBANK",
    "AXISBANK",
    "KOTAKBANK",
    "IT",
    "HCLTECH",
    "INFY",
    "TCS",
    "HDFCAMC",
    "NAM-INDIA",
    "HDFCLIFE",
    "ICICIPRULI",
    "ICICIGI",
    "BAJAJFINSV",
    "BAJAJHLDNG",
    "BAJFINANCE",
    "HINDUNILVR",
    "NESTLEIND",
    "PGHH",
    "PIDILITIND",
    "COLPAL",
    "DABUR",
    "GILLETTE",
    "MARICO",
    "ITC",
    "TITAN",
    "PAGEIND",
    "BATAINDIA",
    "HAVELLS",
    "WHIRLPOOL",
    "GLAXO",
    "ABBOTINDIA",
    "PFIZER",
    "SANOFI",
    # "PAINT"
    "AKZOINDIA",
    "ASIANPAINT",
    "BERGEPAINT",
    "BAJAJ-AUTO",
]
data_v40_next = [
    # V40 Next
    "EQUITASBNK",
    "UJJIVANSFB",
    # "NON-BANKING",
    "5PAISA",
    "ANGELONE",
    "ISEC",
    "MOTILALOFS",
    "MCX",
    "IT",
    "OFSS",
    "TATAELXSI",
    # "MANPOWER",
    "TEAMLEASE",
    "SIS",
    "ASTRAZEN",
    "BAYERCROP",
    "ERIS",
    "LALPATHLAB",
    # "CHEMICAL",
    "FINEORG",
    "CAPLIPOINT",
    "VINATIORGA",
    "INDIGOPNTS",
    "KANSAINER",
    "3MINDIA",
    "GODREJCP",
    "FINCABLES",
    "DIXON",
    "CERA",
    "HONAUT",
    "JCHAC",
    "LUXIND",
    "POLYCAB",
    "RAJESHEXPO",
    "RELAXO",
    "SFL",
    "SYMPHONY",
    "VIPIND",
    "TTKPRESTIG",
    # "AUTO",
    "BOSCHLTD",
    "EICHERMOT",
    # "LIQUOR",
    "UNITDSPR",
    "RADICO",
    # "MEDIA",
    "SUNTV"
]

# Append '.NS' to each string in the list
data_V40_ns = [item + ".NS" for item in data_v40]
data_V40_next_ns = [item + ".NS" for item in data_v40_next]

# Combine the lists
data_with_ns = data_V40_ns + data_V40_next_ns

# Stochastic indicator for 5% gain.
import pandas as pd
import yfinance as yf
from datetime import datetime, timedelta

stochastic_5_gain = []
for stock in data_with_ns:
  data = yf.download(stock, start=datetime.today().date()- timedelta(days=20), end=datetime.today().date())

  # Calculate %K
  data['Lowest Low'] = data['Low'].rolling(window=4).min()
  data['Highest High'] = data['High'].rolling(window=4).max()
  # data = data[4:]

  data['%KD'] = None  # Initialize the column

  for i in range(len(data)):
    lowest_low = data['Lowest Low'].iloc[i]
    highest_high = data['Highest High'].iloc[i]
    close = data['Close'].iloc[i].item()

    # Ensure no division by zero
    if highest_high != lowest_low:
      data.at[i, '%KD'] = ((close - lowest_low) / (highest_high - lowest_low)) * 100

    else:
      data.at[i, '%KD'] = None  # Or 0, depending on the desired behavior

  KD = data['%KD'].dropna().apply(pd.to_numeric, errors='coerce').dropna()

  data['%K'] = KD.rolling(window=3).mean()

  K = data['%K'].apply(pd.to_numeric, errors='coerce')
  data['%D'] = K.rolling(window=3).mean()

  index = -1  # Start from the last row
  last_row = data.iloc[index]  # Get the last row

  # Loop until a valid row is found (where neither %K nor %D is NaN)
  while pd.isna(last_row['%K']).any() or pd.isna(last_row['%D']).any():
    index -= 1  # Move to the previous row
    if abs(index) > len(data):  # Prevent infinite loop if all rows are NaN
      print("All rows contain NaN for %K or %D. Skipping stock.")
      last_row = None
      break
    last_row = data.iloc[index]  # Get the new row
  # print(last_row['%K'].item())
  if last_row['%K'].item() < 20 and last_row['%D'].item() < 20:
    stochastic_5_gain.append(stock)
    print(stock + ": both %K and %D are less than 20%")

# V20 strategy for 20% gains.
import yfinance as yf
import pandas as pd

V20_20_gain = []
for stock_symbol in data_with_ns:
# Define the stock symbol and time period
  # stock_symbol = 'JCHAC.NS'  # Change this to the stock symbol you want
  # start_date = '2023-08-30'  # Adjust the start date as needed
  # end_date = '2024-08-30'    # Adjust the end date as needed

  # Fetch historical data
  data = yf.download(stock_symbol, start=datetime.today().date()- timedelta(days=60), end=datetime.today().date())
  # Identify green candles (where Close > Open)
  data['Green Candle'] = data['Close'] > data['Open']

  # Initialize lists to track the series of green candles
  lower_values = []
  upper_values = []
  lower_dates = []
  upper_dates = []

  # Initialize variables to track the series of green candles
  in_series = False
  series_low = float('inf')
  series_low_date = None
  series_high = float(0)
  series_high_date = None

  for i in range(len(data)):
      if data['Green Candle'].iloc[i]:
          if not in_series:
              # Start a new series
              series_low = data['Low'].iloc[i].item()
              series_low_date = data.index[i]
              in_series = True
          else:
              # Update the lowest low if it is lower than current
              if data['Low'].iloc[i].item() < series_low:
                  series_low = data['Low'].iloc[i].item()
                  series_low_date = data.index[i]

          if data['High'].iloc[i].item() > series_high:
              series_high = data['High'].iloc[i].item()
              series_high_date = data.index[i]

      else:
          # End of the series if a red candle is found
          if in_series and series_low_date < series_high_date:
              # Calculate the percentage difference
              if (series_high - series_low) / series_low >= 0.20:
                  lower_values.append(series_low)
                  upper_values.append(series_high)
                  lower_dates.append(series_low_date)
                  upper_dates.append(series_high_date)
          # Reset the series
          in_series = False
          series_low = float('inf')
          series_low_date = None
          series_high = 0.0
          series_high_date = None

  # Check the last series if it ended without encountering a red candle
  if in_series and series_low_date < series_high_date:
      if (series_high - series_low) / series_low >= 0.20:
          lower_values.append(series_low)
          upper_values.append(series_high)
          lower_dates.append(series_low_date)
          upper_dates.append(series_high_date)

  try:
    current_close = data['Close'].iloc[-1].item()
  except:
    current_close = data['Close'].iloc[-2].item()

  # Print all found pairs of lower and upper values with dates
  if lower_values:
     for i in range(len(lower_values)):
        if abs((current_close - lower_values[i]) / lower_values[i]) <= 0.05:
          V20_20_gain.append(f'Stock: {stock_symbol} Pair {i + 1}: Lower Value: {lower_values[i]} on {lower_dates[i]}, Upper Value: {upper_values[i]} on {upper_dates[i]}')
          print(f'Stock: {stock_symbol} Pair {i + 1}: Lower Value: {lower_values[i]} on {lower_dates[i]}, Upper Value: {upper_values[i]} on {upper_dates[i]}')

# 200days SMA. Buy if 200>50>20
import yfinance as yf
import pandas as pd

SMA_200Days_BUY = []
SMA_200Days_SELL = []
for stock_symbol in data_V40_ns:
# Define the stock symbol and time period
  # stock_symbol = 'JCHAC.NS'  # Change this to the stock symbol you want
  # start_date = '2022-01-01'  # Start date should be at least 200 days before today
  # end_date = '2024-08-30'    # Adjust the end date as needed

  # Fetch historical data
  data = yf.download(stock_symbol, start=datetime.today().date()- timedelta(days=365), end=datetime.today().date())

  # Calculate the 200-day Simple Moving Average (SMA)
  data['200-Day SMA'] = data['Close'].rolling(window=200).mean()

  # Calculate the 50-day Simple Moving Average (SMA)
  data['50-Day SMA'] = data['Close'].rolling(window=50).mean()

  # Calculate the 50-day Simple Moving Average (SMA)
  data['20-Day SMA'] = data['Close'].rolling(window=20).mean()

  if(data['200-Day SMA'].iloc[-1] > data['50-Day SMA'].dropna().iloc[-1]
    and data['50-Day SMA'].dropna().iloc[-1] > data['20-Day SMA'].dropna().iloc[-1]):
    print('BUY: '+ stock_symbol)
    SMA_200Days_BUY.append(stock_symbol)

  if(data['200-Day SMA'].iloc[-1] < data['50-Day SMA'].dropna().iloc[-1]
    and data['50-Day SMA'].dropna().iloc[-1] < data['20-Day SMA'].dropna().iloc[-1]):
    print('SELL: '+ stock_symbol)
    SMA_200Days_SELL.append(stock_symbol)

# RSI indicator: to buy below 30 and sell above 80
import yfinance as yf
import pandas as pd
import warnings

# Ignore all warnings
warnings.filterwarnings("ignore")

# Calculate RSI
def calculate_rsi(data, period=14):
    # Calculate the percentage change as (current close - previous close) / previous close
    data['Change'] = (data['Close'].diff()) / data['Close'].shift(1)
    # Calculate gain and loss
    data['Gain'] = data['Change'].apply(lambda x: x if x > 0 else 0)
    data['Loss'] = data['Change'].apply(lambda x: abs(x) if x < 0 else 0)

    period = 14

    data['Avg Gain'] = 0.0
    data['Avg Loss'] = 0.0

    data.loc[data.index[period - 1], 'Avg Gain']  = sum(data['Gain'].iloc[0:period]) / period
    data.loc[data.index[period - 1], 'Avg Loss'] = sum(data['Loss'].iloc[0:period]) / period

    for i in range(period, len(data)):
      data.loc[data.index[i], 'Avg Gain'] = (data['Avg Gain'].iloc[i-1] * (period - 1) + data['Gain'].iloc[i]) / period
      data.loc[data.index[i], 'Avg Loss'] = (data['Avg Loss'].iloc[i-1] * (period - 1) + data['Loss'].iloc[i]) / period

    data['RS'] = data['Avg Gain'] / data['Avg Loss']

    # Calculate RSI
    data['RSI'] = 100 - (100 / (1 + data['RS']))

    # Drop NaN values
    data = data.dropna()

    return data['RSI']

# Get stocks with RSI BUY indicator.
RSI_LT_30_BUY = []
RSI_GT_80_SELL = []
for stock_symbol in data_with_ns:
    data = yf.download(stock_symbol, start=datetime.today().date()- timedelta(days=60), end=datetime.today().date())
    rsi = calculate_rsi(data, period=14)
    # Check if RSI is below 30 for any of the last 30 days
    if rsi.tail(5).lt(30).any():
        # Print the data if the condition is met
        # pd.set_option('display.max_rows', None)
        # print(data.tail(5))
        print(stock_symbol + " - BUY")
        RSI_LT_30_BUY.append(stock_symbol)
    if rsi.tail(5).gt(80).any():
        # Print the data if the condition is met
        # pd.set_option('display.max_rows', None)
        # print(data.tail(5))
        print(stock_symbol + " - SELL")
        RSI_GT_80_SELL.append(stock_symbol)

# ROB Booker Knoxville Divergence: Buy at downtrending line, sell at uptrending line.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import yfinance as yf
from datetime import datetime, timedelta

RB_KNOXVILLE_BUY = []
RB_KNOXVILLE_SELL = []
# Function to calculate Momentum
def calculate_momentum(data, period=20):
    momentum = data['Close'].diff(period)
    return momentum

def calculate_momentum_diff(data, period=19):
    momentum = data['Momentum'].diff(period)
    return momentum


# Knoxville Divergence Logic
def knoxville_divergence(data, rsi_period=14, momentum_period=20):
    data['RSI'] = calculate_rsi(data, period=rsi_period)
    data['Momentum'] = calculate_momentum(data, period=momentum_period)

    data['Momentum_Diff'] = calculate_momentum_diff(data, period=momentum_period)
    divergence_downtrending = (data['RSI'] < 30) \
                            & (data['Momentum'] < 0) \
                            & (data['Momentum_Diff'] > 0)
    data['Knoxville Divergence Downtrending'] = divergence_downtrending
    divergence_uptrending = (data['RSI'] >70) \
                            & (data['Momentum'] > 0) \
                            & (data['Momentum_Diff'] < 0)
    data['Knoxville Divergence Uptrending'] = divergence_uptrending
    return data

  # Fetch data using yfinance
start_date = datetime.today().date() - timedelta(days=365)
end_date = datetime.today().date() - timedelta(days=1)
for stock in data_V40_ns:
  data = yf.download(stock, start=start_date, end=end_date)

  # Calculate Knoxville Divergence
  result = knoxville_divergence(data)
  if result['Knoxville Divergence Downtrending'].tail(10).any():
    print(stock + '- BUY')
    RB_KNOXVILLE_BUY.append(stock)
  if result['Knoxville Divergence Uptrending'].tail(10).any():
    print(stock + '- SELL')
    RB_KNOXVILLE_SELL.append(stock)
  # result[[ 'Close', 'Momentum', 'Momentum_Diff',  'Knoxville Divergence Downtrending', 'Knoxville Divergence Uptrending']]

# 52 Week High Low
import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
from tabulate import tabulate

LOW_52_WEEK_BUY = []
HIGH_52_WEEK_SELL = []
for stock in data_V40_ns:
  data = yf.download(stock, start=datetime.today().date()- timedelta(days=400), end=datetime.today().date())

  data['52 Week High'] = data['High'].rolling(window=251, min_periods=1).max()
  data['52 Week Low'] = data['Low'].rolling(window=251, min_periods=1).min()

  # Check if the stock was at 52 week low in last 30 days
  for i in range(-10, 0):  # Iterate over the last 30 days
      if data['Low'].iloc[i].item() == data['52 Week Low'].iloc[i].item():
          print(stock + " - TOUCHED 52-WEEK LOW IN LAST 10 DAYS")
          print(data.iloc[i])
          LOW_52_WEEK_BUY.append(stock)
          break
      if data['High'].iloc[i].item() == data['52 Week High'].iloc[i].item():
          print(stock + " - TOUCHED 52-WEEK HIGH IN LAST 10 DAYS")
          print(data.iloc[i])
          HIGH_52_WEEK_SELL.append(stock)
          break

  # print(tabulate(data[['High', 'Low', '52 Week High', '52 Week Low']], headers="keys", tablefmt="pretty"))

  # break

print('*************STOCHASTIC 5% GAIN BUY STOCKS************')
print(stochastic_5_gain)
print('\n*************V20 20% GAIN BUY STOCKS************')
print(V20_20_gain)
print('\n*************200 DAYS MOVING AVERAGE BUY***********')
print(SMA_200Days_BUY)
print('\n*************LOW 52 WEEK BUY STOCKS************')
print(LOW_52_WEEK_BUY)
print('\n*************ROB BOOKER KNOCKVILLE BUY STOCKS************')
print(RB_KNOXVILLE_BUY)
print('\n*************RSI BUY STOCKS************')
print(RSI_LT_30_BUY)

print('\n\n*************200 DAYS MOVING AVERAGE SELL***********')
print(SMA_200Days_SELL)
print('\n*************RSI SELL STOCKS************')
print(RSI_GT_80_SELL)
print('\n*************ROB BOOKER KNOCKVILLE SELL STOCKS************')
print(RB_KNOXVILLE_SELL)
print('\n*************HIGH 52 WEEK SELL STOCKS************')
print(HIGH_52_WEEK_SELL)

# Get Buy and Sell Signals based on Stock Performance, and current Holdings.
#
# Analyse stock performance:
# * Compare Quarterly Results: Should have growing sales, net profit, operating
#   profit and profit before tax
# * Compare Profit and Loss Statements: Should have an overall increasing
#   profits.
# * Get current market sentiments for the sector and the company.
# Get Current stock holdings:
# * Buy: If the current stock holding is less than 5% of total defined assets.
# * Sell: Sell the number of stocks bought for the given strategy.

# # Rob Booker Knoxville Divergence.
# import yfinance as yf
# import pandas as pd
# import numpy as np
# import matplotlib.pyplot as plt


# def calculate_momentum(data, period=20):
#     """Calculate the Momentum indicator"""
#     momentum = data['Close'] - data['Close'].shift(period)
#     print(momentum[-10:])
#     return momentum

# def find_divergences(data, rsi, momentum):
#     """Find divergence points"""
#     divergences = []
#     for i in range(1, len(data)):
#         if (data['Close'].iloc[i].item() > data['Close'].iloc[i - 1].item() and
#             rsi.iloc[i] < rsi.iloc[i - 1] and
#             momentum.iloc[i] < momentum.iloc[i - 1]):
#             divergences.append({
#                 'Date': data.index[i],
#                 'Price': data['Close'].iloc[i],
#                 'RSI': rsi.iloc[i],
#                 'Momentum': momentum.iloc[i]
#             })
#     return divergences

# # Define stock symbol and time period
# stock_symbol = 'INFY.NS'  # Change this to the stock symbol you want
# # start_date = '2024-07-01'
# # end_date = '2024-08-30'

# # Fetch historical data
# # data = yf.download(stock_symbol, start=start_date, end=end_date)
# data = yf.download(stock_symbol, start=datetime.today().date()- timedelta(days=60), end=datetime.today().date()- timedelta(days=1))

# print(type(data))
# # Calculate indicators
# rsi = calculate_rsi( data, period=14)
# # print(type(values))
# data['RSI'] = rsi
# data['Momentum'] = calculate_momentum(data)

# # Drop rows with NaN values
# data.dropna(inplace=True)

# # Find divergences
# divergences = find_divergences(data, data['RSI'], data['Momentum'])

# # Print divergence points
# if divergences:
#     print(f'Found {len(divergences)} divergence points:')
#     for i, divergence in enumerate(divergences):
#         print(f"Divergence {i + 1}: Date: {divergence['Date'].date()}, Price: {divergence['Price']:.2f}, RSI: {divergence['RSI']:.2f}, Momentum: {divergence['Momentum']:.2f}")
# else:
#     print('No divergences found.')

# # Optional: Plot RSI and Momentum
# plt.figure(figsize=(14, 7))

# plt.subplot(3, 1, 1)
# plt.plot(data.index, data['Close'], label='Close Price')
# plt.title(f'{stock_symbol} Price')
# plt.legend()

# plt.subplot(3, 1, 2)
# plt.plot(data.index, data['RSI'], label='RSI (14)', color='orange')
# plt.axhline(30, linestyle='--', color='red')
# plt.axhline(80, linestyle='--', color='green')
# plt.title('RSI')
# plt.legend()

# plt.subplot(3, 1, 3)
# plt.plot(data.index, data['Momentum'], label='Momentum (20)', color='blue')
# plt.title('Momentum')
# plt.legend()

# plt.tight_layout()
# plt.show()

# import numpy as np
# import pandas as pd
# import matplotlib.pyplot as plt
# import yfinance as yf
# from datetime import datetime, timedelta

# def calculate_momentum(data, period=20):
#     return data.diff(periods=period)

# def knoxville_divergence(data, bars_back=200, rsi_period=14, momentum_period=20):
#     rsi = calculate_rsi(data, rsi_period)
#     print("RSI")
#     print(rsi)
#     momentum = calculate_momentum(data, momentum_period)
#     divergence = []

#     for i in range(bars_back, len(data)):
#         rsi_window = rsi[i-bars_back:i]
#         momentum_window = momentum[i-bars_back:i]

#         # Uptrending condition: RSI is oversold and momentum is positive
#         if rsi.iloc[-1].item() < 30 and momentum.iloc[-1].item() > 0:
#             divergence.append((data.index[i], data.iloc[i].item()))

#         # Downtrending condition: RSI is overbought and momentum is negative
#         elif rsi.iloc[-1].item() > 70 and momentum.iloc[-1].item() < 0:
#             divergence.append((data.index[i], data.iloc[i].item()))

#     return divergence

# # Fetch data using yfinance
# start_date = datetime.today().date() - timedelta(days=365)
# end_date = datetime.today().date() - timedelta(days=1)
# data = yf.download('3MINDIA.NS', start=start_date, end=end_date)

# # Use the adjusted closing price for calculations
# prices = data['Adj Close']

# # Knoxville Divergence Parameters
# bars_back = 200
# rsi_period = 14
# momentum_period = 20

# # Find Knoxville Divergence
# divergence_points = knoxville_divergence(prices, bars_back, rsi_period, momentum_period)
# print("DIVERGENCE POINTS")
# print(divergence_points)
# # Separate uptrending and downtrending points
# uptrend_points = [point for point in divergence_points if prices[point[0]] > prices.iloc[0]]
# downtrend_points = [point for point in divergence_points if prices[point[0]] < prices.iloc[0]]

# # Plot
# plt.figure(figsize=(14, 7))
# plt.plot(prices, label="Price", color='blue')
# plt.scatter([point[0] for point in uptrend_points], [point[1] for point in uptrend_points], color='green', label='Uptrend Divergence')
# plt.scatter([point[0] for point in downtrend_points], [point[1] for point in downtrend_points], color='red', label='Downtrend Divergence')
# plt.title("Knoxville Divergence for INFY.NS")
# plt.xlabel("Date")
# plt.ylabel("Price")
# plt.legend()
# plt.grid()
# plt.show()